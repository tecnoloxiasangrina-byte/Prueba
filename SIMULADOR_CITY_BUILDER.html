<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini City Builder - Single File</title>
<style>
  :root{
    --cell-size: 44px;
    --cols: 12;
    --rows: 12;
    --bg: #e9f2fb;
    --panel: #ffffff;
    --accent: #3178c6;
    --muted: #6b7280;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
    background: linear-gradient(180deg,#dfeffc 0%, var(--bg) 100%);
    color:#111827;
    display:flex;
    flex-direction:column;
    min-height:100vh;
    align-items:center;
    padding:18px;
    gap:12px;
  }
  header{display:flex;gap:16px;align-items:center;width:100%;max-width:1100px}
  h1{font-size:20px;margin:0}
  .container{display:flex;gap:14px;width:100%;max-width:1100px}
  .left{
    background:var(--panel);
    padding:12px;
    border-radius:10px;
    box-shadow:0 6px 20px rgba(49,120,198,0.08);
    display:flex;
    flex-direction:column;
    gap:12px;
    flex:1 1 560px;
  }
  .toolbar{display:flex;gap:8px;flex-wrap:wrap}
  .btn{
    background:linear-gradient(180deg,#fff,#f3f8ff);
    border:1px solid rgba(17,24,39,0.06);
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    gap:8px;
    font-weight:600;
  }
  .btn.selected{outline:3px solid rgba(49,120,198,0.18)}
  .status{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
  }
  .stat{
    background:#f8fafc;
    padding:8px 10px;
    border-radius:8px;
    font-size:14px;
    min-width:120px;
    text-align:left;
  }
  .game-wrap{
    display:flex;
    gap:12px;
    align-items:flex-start;
  }
  #game{
    display:grid;
    grid-template-columns: repeat(var(--cols), var(--cell-size));
    grid-template-rows: repeat(var(--rows), var(--cell-size));
    gap:2px;
    background:linear-gradient(180deg,#9fd0ff,#d9f0ff);
    padding:6px;
    border-radius:10px;
    box-shadow:inset 0 2px 0 rgba(255,255,255,0.6);
  }
  .cell{
    width:var(--cell-size);
    height:var(--cell-size);
    background: linear-gradient(180deg,#cfe8c6,#dff0d8);
    border-radius:6px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:18px;
    cursor:pointer;
    user-select:none;
    position:relative;
    transition:transform .08s;
  }
  .cell:hover{transform:translateY(-2px)}
  .cell.empty{background:linear-gradient(180deg,#dff4ff,#e9fbff)}
  /* building visuals by class */
  .house{background:linear-gradient(180deg,#fff8e6,#fff0c8); border:1px solid #f1d290}
  .factory{background:linear-gradient(180deg,#f5f5f5,#e6e6e6); border:1px solid #cfcfcf}
  .plant{background:linear-gradient(180deg,#e6f7ff,#ccf0ff); border:1px solid #9fd7ff}
  .park{background:linear-gradient(180deg,#e9ffe8,#d8f6d8); border:1px solid #bfe7c2}
  .building-emoji{font-size:18px}
  .small-label{
    position:absolute;
    bottom:2px;
    right:4px;
    font-size:10px;
    color:var(--muted);
    background:rgba(255,255,255,0.6);
    padding:1px 4px;
    border-radius:6px;
  }

  .right{
    width:320px;
    min-width:260px;
    background:var(--panel);
    padding:12px;
    border-radius:10px;
    box-shadow:0 6px 20px rgba(17,24,39,0.04);
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .panel-title{font-weight:700;margin:0 0 6px 0}
  .list{display:flex;flex-direction:column;gap:8px}
  .row{display:flex;justify-content:space-between;align-items:center}
  .muted{color:var(--muted);font-size:13px}
  .controls{display:flex;gap:8px}
  footer{font-size:13px;color:var(--muted);margin-top:8px}
  .help{font-size:13px;color:var(--muted)}
  @media (max-width:920px){
    .container{flex-direction:column}
    .right{width:100%}
  }
</style>
</head>
<body>
<header>
  <h1>Mini City Builder</h1>
  <div class="help muted">Prototipo: colocar edificios, gestionar dinero y energ√≠a. Guardado autom√°tico.</div>
</header>

<div class="container">
  <div class="left">
    <div class="toolbar" id="toolbar">
      <!-- Botones se generar√°n din√°micamente -->
    </div>

    <div class="status" id="status">
      <!-- Estad√≠sticas generadas din√°micamente -->
    </div>

    <div class="game-wrap">
      <div id="game" aria-label="Mapa de la ciudad"></div>
    </div>

    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:6px">
      <div class="muted">Click para colocar. Pulsa otro bot√≥n para cambiar edificio. </div>
      <div class="controls">
        <button class="btn" id="saveBtn">Guardar</button>
        <button class="btn" id="loadBtn">Cargar</button>
        <button class="btn" id="resetBtn">Reiniciar</button>
      </div>
    </div>
  </div>

  <aside class="right">
    <div>
      <h3 class="panel-title">Informaci√≥n</h3>
      <div class="list" id="infoList">
        <!-- Info din√°mica -->
      </div>
    </div>

    <div>
      <h3 class="panel-title">Reglas r√°pidas</h3>
      <div class="muted">
        - Cada edificio tiene coste inicial.<br>
        - Casas aumentan poblaci√≥n y pagan impuestos.<br>
        - F√°bricas generan ingreso pero consumen energ√≠a.<br>
        - Plantas el√©ctricas generan energ√≠a.<br>
        - Parques aumentan felicidad (solo visual por ahora).
      </div>
    </div>
  </aside>
</div>

<footer>Hecho con HTML, CSS y JavaScript ‚Äî ¬°modifica y ampl√≠a como quieras!</footer>

<script>
/*
  Mini City Builder - Single file prototype
  - Grid-based placement
  - Economic tick
  - localStorage save/load
*/

/* CONFIGURACI√ìN */
const CONFIG = {
  cols: 12,
  rows: 12,
  tickIntervalMs: 1000, // 1 segundo por tick
  taxPerPerson: 1,      // dinero por persona por tick
  startingMoney: 1500,
  startingPopulation: 0
};

/* Definici√≥n de tipos de edificio */
const BUILDINGS = {
  none: { id: 'none', name: 'Mover', emoji: '‚úã', cost: 0, power: 0, pop:0, income:0, maintenance:0, desc: 'Selecciona para mover/inspeccionar' },
  house: { id: 'house', name: 'Casa', emoji: 'üè†', cost: 100, power: -1, pop:5, income: 0, maintenance: 1, desc:'Aumenta poblaci√≥n' },
  factory: { id: 'factory', name: 'F√°brica', emoji: 'üè≠', cost: 500, power: -3, pop:0, income: 20, maintenance: 3, desc:'Genera ingresos, consume energ√≠a' },
  plant: { id: 'plant', name: 'Planta', emoji: '‚ö°', cost: 800, power: +10, pop:0, income: 0, maintenance: 4, desc:'Genera energ√≠a' },
  park: { id: 'park', name: 'Parque', emoji: 'üå≥', cost: 200, power: 0, pop:0, income: 0, maintenance: 0, desc:'Mejora felicidad' }
};

/* ESTADO DEL JUEGO */
let state = {
  money: CONFIG.startingMoney,
  population: CONFIG.startingPopulation,
  energy: 0, // balance energ√≠a (generada - consumida)
  happiness: 50,
  buildings: [], // matriz rows x cols con id de edificio o null
  tickCount: 0
};

let selectedBuilding = 'house';
const gameEl = document.getElementById('game');
const toolbarEl = document.getElementById('toolbar');
const statusEl = document.getElementById('status');
const infoListEl = document.getElementById('infoList');

/* Inicializar matriz de edificios */
function initBuildingsArray() {
  state.buildings = [];
  for (let y=0;y<CONFIG.rows;y++){
    const row = [];
    for (let x=0;x<CONFIG.cols;x++){
      row.push(null);
    }
    state.buildings.push(row);
  }
}

/* UI: crear botones del toolbar */
function createToolbar(){
  toolbarEl.innerHTML = '';
  for (const key of Object.keys(BUILDINGS)){
    const b = BUILDINGS[key];
    const btn = document.createElement('button');
    btn.className = 'btn' + (key===selectedBuilding ? ' selected' : '');
    btn.setAttribute('data-id', b.id);
    btn.title = `${b.name} ‚Äî Coste: ${b.cost} ‚Äî ${b.desc}`;
    btn.innerHTML = `<span style="font-size:16px">${b.emoji}</span> <span style="font-size:13px">${b.name}</span>`;
    btn.addEventListener('click', ()=> {
      selectedBuilding = b.id;
      document.querySelectorAll('#toolbar .btn').forEach(el=>el.classList.remove('selected'));
      btn.classList.add('selected');
      updateInfoPanel();
    });
    toolbarEl.appendChild(btn);
  }
}

/* Crear celdas del juego */
function renderGrid(){
  gameEl.style.setProperty('--cols', CONFIG.cols);
  gameEl.style.setProperty('--rows', CONFIG.rows);
  gameEl.innerHTML = '';
  for (let y=0;y<CONFIG.rows;y++){
    for (let x=0;x<CONFIG.cols;x++){
      const div = document.createElement('div');
      div.className = 'cell empty';
      div.dataset.x = x;
      div.dataset.y = y;
      div.addEventListener('click', cellClicked);
      gameEl.appendChild(div);
    }
  }
  reRenderBuildings();
}

/* Re-render de edificios en el grid */
function reRenderBuildings(){
  for (let y=0;y<CONFIG.rows;y++){
    for (let x=0;x<CONFIG.cols;x++){
      const idx = y*CONFIG.cols + x;
      const cellEl = gameEl.children[idx];
      const bid = state.buildings[y][x];
      cellEl.className = 'cell';
      if (!bid){
        cellEl.classList.add('empty');
        cellEl.innerHTML = '';
      } else {
        const b = BUILDINGS[bid];
        cellEl.classList.add(b.id);
        // Mostrar emoji + peque√±o label
        cellEl.innerHTML = `<div class="building-emoji">${b.emoji}</div><div class="small-label">${b.name}</div>`;
      }
    }
  }
}

/* Manejo click en celda: colocar o inspeccionar */
function cellClicked(e){
  const x = Number(e.currentTarget.dataset.x);
  const y = Number(e.currentTarget.dataset.y);
  const existing = state.buildings[y][x];

  if (selectedBuilding === 'none'){
    // Inspecci√≥n: mostrar info de la celda
    if (existing){
      alert(`Celda (${x},${y}): ${BUILDINGS[existing].name}\nCoste inicial: ${BUILDINGS[existing].cost}`);
    } else {
      alert(`Celda (${x},${y}): Vac√≠a`);
    }
    return;
  }

  // Intentar colocar el edificio seleccionado
  const buildingDef = BUILDINGS[selectedBuilding];
  if (!buildingDef) return;

  // Si ya hay un edificio, no permitir colocar encima
  if (existing){
    // Si el edificio es el mismo, nada; si quieres, se puede vender
    const sell = confirm("Ya hay un edificio. ¬øQuieres venderlo por la mitad del coste?");
    if (sell){
      const soldDef = BUILDINGS[existing];
      const refund = Math.floor(soldDef.cost/2);
      state.money += refund;
      state.buildings[y][x] = null;
      recalcStateFromBuildings();
      reRenderBuildings();
      updateStatus();
      saveToLocalStorage();
    }
    return;
  }

  // Verificar dinero suficiente
  if (state.money < buildingDef.cost){
    alert("No tienes suficiente dinero para construir eso.");
    return;
  }

  // Colocar
  state.money -= buildingDef.cost;
  state.buildings[y][x] = buildingDef.id;
  // Actualizar estado derivado (poblaci√≥n, energia, etc)
  recalcStateFromBuildings();
  reRenderBuildings();
  updateStatus();
  saveToLocalStorage();
}

/* Recalcula poblaci√≥n, energ√≠a generada/consumida, mantenimiento y happiness desde la matriz */
function recalcStateFromBuildings(){
  let pop = 0;
  let energy = 0;
  let maintenance = 0;
  let happiness = 50; // base
  let incomeFromBuildings = 0;

  for (let y=0;y<CONFIG.rows;y++){
    for (let x=0;x<CONFIG.cols;x++){
      const bId = state.buildings[y][x];
      if (!bId) continue;
      const b = BUILDINGS[bId];
      pop += b.pop || 0;
      energy += b.power || 0;
      maintenance += b.maintenance || 0;
      incomeFromBuildings += b.income || 0;
      if (bId === 'park') happiness += 5;
    }
  }

  state.population = pop;
  state.energy = energy;
  state.maintenance = maintenance;
  state.baseBuildingIncome = incomeFromBuildings;
  state.happiness = Math.min(100, Math.max(0, happiness));
}

/* Tick de juego que corre cada segundo */
function gameTick(){
  state.tickCount++;
  // ingresos por impuestos de la poblaci√≥n
  const taxIncome = Math.floor(state.population * CONFIG.taxPerPerson);
  // ingresos por f√°bricas (precalculado)
  const buildingIncome = state.baseBuildingIncome || 0;
  // costos por mantenimiento
  const maintenanceCost = state.maintenance || 0;
  // si la energ√≠a es negativa, puedes penalizar (reducir ingresos)
  let energyPenalty = 0;
  if (state.energy < 0){
    // penaliza ingresos si no hay suficiente energ√≠a
    energyPenalty = Math.ceil(Math.abs(state.energy) * 0.2); // 20% por unidad faltante (simple)
  }
  // calcular total y aplicar
  const netGain = taxIncome + buildingIncome - maintenanceCost - energyPenalty;
  state.money += netGain;

  // ajustar felicidad ligeramente si hay problemas
  if (state.energy < 0) state.happiness = Math.max(0, state.happiness - 1);
  else state.happiness = Math.min(100, state.happiness + 0.2);

  // l√≠mites y seguridad
  state.money = Math.max(-999999, Math.round(state.money));
  state.happiness = Math.round(state.happiness*10)/10;

  updateStatus();
  if (state.tickCount % 5 === 0) { // guardar cada 5 ticks
    saveToLocalStorage();
  }
}

/* Update panel de status */
function updateStatus(){
  statusEl.innerHTML = '';
  const money = createStatEl('Dinero', `‚Ç¨ ${state.money}`);
  const pop = createStatEl('Poblaci√≥n', `${state.population}`);
  const energy = createStatEl('Energ√≠a', `${state.energy} (balance)`);
  const happiness = createStatEl('Felicidad', `${state.happiness}`);
  const maintenance = createStatEl('Mantenimiento', `${state.maintenance || 0} /tick`);
  statusEl.appendChild(money);
  statusEl.appendChild(pop);
  statusEl.appendChild(energy);
  statusEl.appendChild(happiness);
  statusEl.appendChild(maintenance);

  updateInfoPanel();
}

/* Crear elemento stat */
function createStatEl(title, value){
  const el = document.createElement('div');
  el.className = 'stat';
  el.innerHTML = `<div style="font-size:12px;color:var(--muted)">${title}</div><div style="font-weight:700;margin-top:6px">${value}</div>`;
  return el;
}

/* Panel derecho con info del edificio seleccionado y reglas */
function updateInfoPanel(){
  infoListEl.innerHTML = '';
  const sel = BUILDINGS[selectedBuilding];
  const selectedEl = document.createElement('div');
  selectedEl.className = 'row';
  selectedEl.innerHTML = `<div><strong>${sel.name}</strong> <span class="muted">(${sel.emoji})</span><div class="muted" style="font-size:13px">${sel.desc}</div></div><div style="text-align:right">Coste: ‚Ç¨${sel.cost}</div>`;
  infoListEl.appendChild(selectedEl);

  // mostrar resumen de ingresos/penalizaciones
  const breakdown = document.createElement('div');
  breakdown.innerHTML = `
    <div class="row muted"><div>Impuestos por poblaci√≥n</div><div>‚Ç¨ ${state.population * CONFIG.taxPerPerson}</div></div>
    <div class="row muted"><div>Ingresos de edificios</div><div>‚Ç¨ ${state.baseBuildingIncome || 0}</div></div>
    <div class="row muted"><div>Mantenimiento</div><div>‚Ç¨ ${state.maintenance || 0}</div></div>
  `;
  infoListEl.appendChild(breakdown);
}

/* Save / Load (localStorage) */
const STORAGE_KEY = 'mini-city-builder-save';

function saveToLocalStorage(){
  const saveObj = {
    money: state.money,
    population: state.population,
    energy: state.energy,
    happiness: state.happiness,
    buildings: state.buildings,
    tickCount: state.tickCount
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(saveObj));
  // console.log('Guardado');
}

function loadFromLocalStorage(){
  const s = localStorage.getItem(STORAGE_KEY);
  if (!s) {
    alert('No hay partida guardada.');
    return false;
  }
  try {
    const obj = JSON.parse(s);
    state.money = obj.money ?? CONFIG.startingMoney;
    state.population = obj.population ?? 0;
    state.energy = obj.energy ?? 0;
    state.happiness = obj.happiness ?? 50;
    state.buildings = obj.buildings ?? state.buildings;
    state.tickCount = obj.tickCount ?? 0;
    recalcStateFromBuildings();
    reRenderBuildings();
    updateStatus();
    return true;
  } catch(e){
    alert('Error al cargar la partida.');
    return false;
  }
}

/* Reset del juego */
function resetGame(){
  if (!confirm('Reiniciar la partida y perder el progreso actual?')) return;
  state.money = CONFIG.startingMoney;
  state.population = CONFIG.startingPopulation;
  state.energy = 0;
  state.happiness = 50;
  initBuildingsArray();
  recalcStateFromBuildings();
  reRenderBuildings();
  updateStatus();
  saveToLocalStorage();
}

/* Eventos botones guardar/cargar/reiniciar */
document.getElementById('saveBtn').addEventListener('click', ()=> {
  saveToLocalStorage();
  alert('Partida guardada.');
});
document.getElementById('loadBtn').addEventListener('click', ()=> {
  const ok = loadFromLocalStorage();
  if (ok) alert('Partida cargada.');
});
document.getElementById('resetBtn').addEventListener('click', resetGame);

/* Inicializaci√≥n */
function init(){
  initBuildingsArray();
  recalcStateFromBuildings();
  createToolbar();
  renderGrid();
  updateStatus();

  // Intentar cargar partida guardada al inicio (si existe)
  const saved = localStorage.getItem(STORAGE_KEY);
  if (saved){
    // no preguntar: carga silenciosa para que veas tu progreso
    loadFromLocalStorage();
  }

  // Start tick
  setInterval(gameTick, CONFIG.tickIntervalMs);
}

/* Lanzar */
init();

/* Nota: puedes ampliar esto a√±adiendo:
   - restricciones de zonificaci√≥n
   - caminos que modifiquen empleo/pop
   - coste de electricidad por tick, demanda/producci√≥n m√°s realista
   - evoluci√≥n de edificios con tiempo
   - interfaz de construcci√≥n m√°s avanzada
*/
</script>
</body>
</html>
